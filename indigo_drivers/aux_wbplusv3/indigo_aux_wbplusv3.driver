// 
// All rights reserved.
//
// You can use this software under the terms of 'INDIGO Astronomy
// open-source license' (see LICENSE.md).
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHORS 'AS IS' AND ANY EXPRESS
// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// WandererBox Plus V3 Powerbox driver definition

// TODO: Test with real hardware or simulator!!!

driver wbplusv3 {
	label = "WandererBox Plus V3 Powerbox";
	author = "Rumen G. Bogdanovski <rumenastro@gmail.com>";
	copyright = "";
	version = 4;
	serial;
	// include { }
	define {
		#define AUX_GROUP	"Powerbox"
		#define WEATHER_GROUP	"Weather"
		#define DEVICE_ID "ZXWBPlusV3"
	}
	data {
		char model_id[1550];
		char firmware[20];
		double probe_temperature;
		double dht22_hunidity;
		double dht22_temperature;
		double input_current;
		double input_voltage;
		bool usb_status;
		bool dc2_status;
		uint8_t dc3_pwm;
		bool dc4_6_status;
		double dc2_voltage;
	}
	code {
		static bool wbplusv3_read_status(indigo_device *device) {
			char status[256] = { 0 };
			indigo_uni_discard(PRIVATE_DATA->handle);
			long res = indigo_uni_read_line(PRIVATE_DATA->handle, status, 256);
			if (strncmp(status, DEVICE_ID, strlen(DEVICE_ID))) {   // first part of the message is cleared by tcflush();
				res = indigo_uni_read_line(PRIVATE_DATA->handle, status, 256);
			}
			if (res > 0) {
				char *buf;
				char* token = strtok_r(status, "A", &buf);
				if (token == NULL) {
					return false;
				}
				strncpy(PRIVATE_DATA->model_id, token, sizeof(PRIVATE_DATA->model_id));
				if (strcmp(PRIVATE_DATA->model_id, DEVICE_ID)) {
					return false;
				}
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				strncpy(PRIVATE_DATA->firmware, token, sizeof(PRIVATE_DATA->firmware));
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->probe_temperature = atof(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				if (!strcmp(token, "nan")) {
					PRIVATE_DATA->dht22_hunidity = -127.0;
				} else {
					PRIVATE_DATA->dht22_hunidity = atof(token);
				}
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				if (!strcmp(token, "nan")) {
					PRIVATE_DATA->dht22_temperature = -127.0;
				} else {
					PRIVATE_DATA->dht22_temperature = atof(token);
				}
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->input_current = atof(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->input_voltage = atof(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->usb_status = atoi(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->dc2_status = atoi(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->dc3_pwm = atoi(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->dc4_6_status = atoi(token);
				token = strtok_r(NULL, "A", &buf);
				if (token == NULL) {
					return false;
				}
				PRIVATE_DATA->dc2_voltage = atof(token)/10.0;
				INDIGO_DRIVER_DEBUG(DRIVER_NAME, "model_id = '%s'\nfirmware = '%s'\nprobe_temperature = %.2fC\ndht22_hunidity = %.2f%%\ndht22_temperature = %.2fC\ninput_current = %.2fA\ninput_voltage = %.2fV\nusb_status = %d\ndc2_status = %d\ndc3_pwm = %d\ndc4_6_status = %d\ndc2_voltage = %.1fV\n", PRIVATE_DATA->model_id, PRIVATE_DATA->firmware, PRIVATE_DATA->probe_temperature, PRIVATE_DATA->dht22_hunidity, PRIVATE_DATA->dht22_temperature, PRIVATE_DATA->input_current, PRIVATE_DATA->input_voltage, PRIVATE_DATA->usb_status, PRIVATE_DATA->dc2_status, PRIVATE_DATA->dc3_pwm, PRIVATE_DATA->dc4_6_status, PRIVATE_DATA->dc2_voltage);
				return true;
			}
			return false;
		}

		static bool wbplusv3_command(indigo_device *device, char *command) {
			indigo_uni_discard(PRIVATE_DATA->handle);
			if (indigo_uni_printf(PRIVATE_DATA->handle, "%s\n", command) > 0) {
				return true;
			}
			return false;
		}

		static bool wbplusv3_open(indigo_device *device) {
			PRIVATE_DATA->handle = indigo_uni_open_serial_with_speed(DEVICE_PORT_ITEM->text.value, 19200, INDIGO_LOG_DEBUG);
			if (PRIVATE_DATA->handle != NULL) {
				indigo_sleep(1);
				if (wbplusv3_read_status(device)) {
					if (!strcmp(PRIVATE_DATA->model_id, DEVICE_ID)) {
						strcpy(INFO_DEVICE_MODEL_ITEM->text.value, PRIVATE_DATA->model_id);
						strcpy(INFO_DEVICE_FW_REVISION_ITEM->text.value, PRIVATE_DATA->firmware);
						indigo_update_property(device, INFO_PROPERTY, NULL);
						return true;
					}
				}
				indigo_uni_close(&PRIVATE_DATA->handle);
				indigo_send_message(device, "Handshake failed");
			}
			return false;
		}

		static void wbplusv3_close(indigo_device *device) {
			if (PRIVATE_DATA->handle != NULL) {
				indigo_uni_close(&PRIVATE_DATA->handle);
			}
		}
	}
	// on_init { }
	// on_shutdown { }
	aux {
		name = "WandererBox Plus V3";
		interface = INDIGO_INTERFACE_AUX_POWERBOX | INDIGO_INTERFACE_AUX_WEATHER;
		additional_instances = true;
		// code { }
		on_timer {
			if (wbplusv3_read_status(device)) {
				AUX_WEATHER_TEMPERATURE_ITEM->number.value = PRIVATE_DATA->dht22_temperature;
				AUX_WEATHER_HUMIDITY_ITEM->number.value = PRIVATE_DATA->dht22_hunidity;
				// calculate dew point
				if (PRIVATE_DATA->dht22_temperature > -100) {
					AUX_WEATHER_PROPERTY->state = INDIGO_OK_STATE;
					AUX_WEATHER_DEWPOINT_ITEM->number.value = indigo_aux_dewpoint(PRIVATE_DATA->dht22_temperature, PRIVATE_DATA->dht22_hunidity);
				} else {
					AUX_WEATHER_PROPERTY->state = INDIGO_IDLE_STATE;
					AUX_WEATHER_DEWPOINT_ITEM->number.value = -273.15;
				}
				indigo_update_property(device, AUX_WEATHER_PROPERTY, NULL);
				AUX_TEMPERATURE_SENSORS_SENSOR_1_ITEM->number.value = PRIVATE_DATA->dht22_temperature;
				AUX_TEMPERATURE_SENSORS_SENSOR_2_ITEM->number.value = PRIVATE_DATA->probe_temperature;
				if (PRIVATE_DATA->dht22_temperature < -100 && PRIVATE_DATA->probe_temperature <-100) {
					AUX_TEMPERATURE_SENSORS_PROPERTY->state = INDIGO_IDLE_STATE;
				} else {
					AUX_TEMPERATURE_SENSORS_PROPERTY->state = INDIGO_OK_STATE;
				}
				indigo_update_property(device, AUX_TEMPERATURE_SENSORS_PROPERTY, NULL);
				AUX_INFO_VOLTAGE_ITEM->number.value = PRIVATE_DATA->input_voltage;
				AUX_INFO_CURRENT_ITEM->number.value = PRIVATE_DATA->input_current;
				indigo_update_property(device, AUX_INFO_PROPERTY, NULL);
				if (AUX_USB_PORT_PROPERTY->state != INDIGO_BUSY_STATE) {
					AUX_USB_PORT_1_ITEM->sw.value = PRIVATE_DATA->usb_status;
					indigo_update_property(device, AUX_USB_PORT_PROPERTY, NULL);
				}
				if (AUX_POWER_OUTLET_PROPERTY->state != INDIGO_BUSY_STATE) {
					AUX_POWER_OUTLET_1_ITEM->sw.value = PRIVATE_DATA->dc2_status;
					AUX_POWER_OUTLET_2_ITEM->sw.value = PRIVATE_DATA->dc4_6_status;
					indigo_update_property(device, AUX_POWER_OUTLET_PROPERTY, NULL);
				}
				if (AUX_POWER_OUTLET_VOLTAGE_PROPERTY->state != INDIGO_BUSY_STATE) {
					AUX_POWER_OUTLET_VOLTAGE_1_ITEM->number.value = PRIVATE_DATA->dc2_voltage;
					indigo_update_property(device, AUX_POWER_OUTLET_VOLTAGE_PROPERTY, NULL);
				}
				if (AUX_HEATER_OUTLET_PROPERTY->state != INDIGO_BUSY_STATE) {
					AUX_HEATER_OUTLET_1_ITEM->number.value = (PRIVATE_DATA->dc3_pwm / 255.0) * 100;
					indigo_update_property(device, AUX_HEATER_OUTLET_PROPERTY, NULL);
				}
				if (AUX_DEW_CONTROL_AUTOMATIC_ITEM->sw.value && AUX_WEATHER_PROPERTY->state == INDIGO_OK_STATE) {
					if (((AUX_WEATHER_DEWPOINT_ITEM->number.value + 1) > PRIVATE_DATA->dht22_temperature) && PRIVATE_DATA->dc3_pwm != 255) {
						wbplusv3_command(device, "3255");
						indigo_send_message(device, "Heating started: Aproaching dewpoint");
					}
					if (((AUX_WEATHER_DEWPOINT_ITEM->number.value + 2) < PRIVATE_DATA->dht22_temperature) && PRIVATE_DATA->dc3_pwm != 0) {
						wbplusv3_command(device, "3000");
						indigo_send_message(device, "Heating stopped: Conditions are dry");
					}
				}
				// Dew point warning
				if (PRIVATE_DATA->dht22_temperature < -100) { // no sensor
					AUX_DEW_WARNING_PROPERTY->state = INDIGO_IDLE_STATE;
					AUX_DEW_WARNING_SENSOR_1_ITEM->light.value = INDIGO_IDLE_STATE;
				} else if (PRIVATE_DATA->dht22_temperature - 1 <= AUX_WEATHER_DEWPOINT_ITEM->number.value) {
					AUX_DEW_WARNING_PROPERTY->state = INDIGO_OK_STATE;
					AUX_DEW_WARNING_SENSOR_1_ITEM->light.value = INDIGO_ALERT_STATE;
				} else {
					AUX_DEW_WARNING_PROPERTY->state = INDIGO_OK_STATE;
					AUX_DEW_WARNING_SENSOR_1_ITEM->light.value = INDIGO_OK_STATE;
				}
				indigo_update_property(device, AUX_DEW_WARNING_PROPERTY, NULL);
			}
			indigo_reschedule_timer(device, 1, &PRIVATE_DATA->aux_timer);
		}
		// on_connect { }
		on_disconnect {
			strcpy(INFO_DEVICE_MODEL_ITEM->text.value, "Unknown");
			strcpy(INFO_DEVICE_FW_REVISION_ITEM->text.value, "Unknown");
			indigo_update_property(device, INFO_PROPERTY, NULL);
		}
		on_attach {
			INFO_PROPERTY->count = 6;
			strcpy(INFO_DEVICE_MODEL_ITEM->text.value, "Unknown");
			strcpy(INFO_DEVICE_FW_REVISION_ITEM->text.value, "Unknown");
		}
		// on_detach { }
		text AUX_OUTLET_NAMES {
			name = AUX_OUTLET_NAMES_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "Outlet names";
			persistent = true;
			always_defined = true;
			// handle_change = false;
			// synchronized_change = false;
			on_change {
				snprintf(AUX_HEATER_OUTLET_1_ITEM->label, INDIGO_NAME_SIZE, "%s (DC3) [%%]", AUX_HEATER_OUTLET_NAME_1_ITEM->text.value);
				snprintf(AUX_POWER_OUTLET_1_ITEM->label, INDIGO_NAME_SIZE, "%s (DC2)", AUX_POWER_OUTLET_NAME_1_ITEM->text.value);
				snprintf(AUX_POWER_OUTLET_VOLTAGE_1_ITEM->label, INDIGO_NAME_SIZE, "%s (DC2) [V]", AUX_POWER_OUTLET_NAME_1_ITEM->text.value);
				snprintf(AUX_POWER_OUTLET_2_ITEM->label, INDIGO_NAME_SIZE, "%s (DC4-DC6)", AUX_POWER_OUTLET_NAME_2_ITEM->text.value);
				if (IS_CONNECTED) {
					indigo_delete_property(device, AUX_HEATER_OUTLET_PROPERTY, NULL);
					indigo_define_property(device, AUX_HEATER_OUTLET_PROPERTY, NULL);
					indigo_delete_property(device, AUX_POWER_OUTLET_PROPERTY, NULL);
					indigo_define_property(device, AUX_POWER_OUTLET_PROPERTY, NULL);
					indigo_delete_property(device, AUX_POWER_OUTLET_VOLTAGE_PROPERTY, NULL);
					indigo_define_property(device, AUX_POWER_OUTLET_VOLTAGE_PROPERTY, NULL);
					indigo_update_property(device, AUX_OUTLET_NAMES_PROPERTY, NULL);
				}
			}
			// on_attach { }
			// on_detach { }
			item AUX_POWER_OUTLET_NAME_1 {
				name = AUX_POWER_OUTLET_NAME_1_ITEM_NAME;
				label = "Regulated outlet (DC2)";
				value = "Regulated outlet";
			}
			item AUX_HEATER_OUTLET_NAME_1 {
				name = AUX_HEATER_OUTLET_NAME_1_ITEM_NAME;
				label = "Heater outlet (DC3)";
				value = "Heater outlet";
			}
			item AUX_POWER_OUTLET_NAME_2 {
				name = AUX_POWER_OUTLET_NAME_2_ITEM_NAME;
				label = "Power outlets (DC4-DC6)";
				value = "Power outlets";
			}
		}
		switch AUX_POWER_OUTLET {
			name = AUX_POWER_OUTLET_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "Power outlets";
			rule = INDIGO_ANY_OF_MANY_RULE;
			// handle_change = false;
			// synchronized_change = false;
			on_change {
				wbplusv3_command(device, AUX_POWER_OUTLET_1_ITEM->sw.value ? "121" : "120");
				wbplusv3_command(device, AUX_POWER_OUTLET_2_ITEM->sw.value ? "101" : "100");
				indigo_sleep(1);
			}
			// on_attach { }
			// on_detach { }
			item AUX_POWER_OUTLET_1 {
				name = AUX_POWER_OUTLET_1_ITEM_NAME;
				label = "Regulated outlet (DC2)";
				value = true;
			}
			item AUX_POWER_OUTLET_2 {
				name = AUX_POWER_OUTLET_2_ITEM_NAME;
				label = "Power outlets (DC4-DC6)";
				value = true;
			}
		}
		number AUX_POWER_OUTLET_VOLTAGE {
			name = AUX_POWER_OUTLET_VOLTAGE_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "Regulated outlets voltage";
			// handle_change = false;
			// synchronized_change = false;
			on_change {
				char command[16];
				snprintf(command, sizeof(command), "%d", 20000 + (int)(AUX_POWER_OUTLET_VOLTAGE_1_ITEM->number.target * 10));
				wbplusv3_command(device, command);
				indigo_sleep(1);
			}
			// on_attach { }
			// on_detach { }
			item AUX_POWER_OUTLET_VOLTAGE_1 {
				name = AUX_POWER_OUTLET_VOLTAGE_1_ITEM_NAME;
				label = "Regulated outlet (DC2) [V]";
				value = 13.2;
				min = 0;
				max = 13.2;
				step = 0.2;
				format = "%.2f";
			}
		}
		switch AUX_USB_PORT {
			name = AUX_USB_PORT_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "USB Ports";
			rule = INDIGO_ANY_OF_MANY_RULE;
			// handle_change = false;
			// synchronized_change = false;
			on_change {
				wbplusv3_command(device, AUX_USB_PORT_1_ITEM->sw.value ? "111" : "110");
				indigo_sleep(1);
			}
			// on_attach { }
			// on_detach { }
			item AUX_USB_PORT_1 {
				name = AUX_USB_PORT_1_ITEM_NAME;
				label = "USB 2.0 && 3.1 ports";
				value = true;
			}
		}
		number AUX_HEATER_OUTLET {
			name = AUX_HEATER_OUTLET_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "Heater outlets";
			// handle_change = false;
			// synchronized_change = false;
			on_change {
				char command[16];
				snprintf(command, sizeof(command), "%d", 3000 + (int)(AUX_HEATER_OUTLET_1_ITEM->number.target * 255.0 / 100.0));
				wbplusv3_command(device, command);
				if (AUX_DEW_CONTROL_AUTOMATIC_ITEM->sw.value) {
					indigo_set_switch(AUX_DEW_CONTROL_PROPERTY, AUX_DEW_CONTROL_MANUAL_ITEM, true);
					indigo_update_property(device, AUX_DEW_CONTROL_PROPERTY, NULL);
				}
				indigo_sleep(1);
			}
			// on_attach { }
			// on_detach { }
			item AUX_HEATER_OUTLET_1 {
				name = AUX_HEATER_OUTLET_1_ITEM_NAME;
				label = "Heater outlet (DC3) [%]";
				value = 0;
				min = 0;
				max = 100;
				step = 5;
				format = "%.0f";
			}
		}
		switch AUX_DEW_CONTROL {
			name = AUX_DEW_CONTROL_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "Dew control";
			// handle_change = false;
			// synchronized_change = false;
			// on_change { }
			// on_attach { }
			// on_detach { }
			item AUX_DEW_CONTROL_MANUAL {
				name = AUX_DEW_CONTROL_MANUAL_ITEM_NAME;
				label = "Manual";
				value = true;
			}
			item AUX_DEW_CONTROL_AUTOMATIC {
				name = AUX_DEW_CONTROL_AUTOMATIC_ITEM_NAME;
				label = "Automatic";
				value = false;
			}
		}
		number AUX_WEATHER {
			name = AUX_WEATHER_PROPERTY_NAME;
			group = WEATHER_GROUP;
			label = "Weather info (DHT22)";
			perm = INDIGO_RO_PERM;
			// handle_change = false;
			// synchronized_change = false;
			// on_change { }
			// on_attach { }
			// on_detach { }
			item AUX_WEATHER_TEMPERATURE {
				name = AUX_WEATHER_TEMPERATURE_ITEM_NAME;
				label = "Temperature [째C]";
				value = 0;
				min = -50;
				max = 100;
				step = 0;
				format = "%.2f";
			}
			item AUX_WEATHER_HUMIDITY {
				name = AUX_WEATHER_HUMIDITY_ITEM_NAME;
				label = "Humidity [%]";
				value = 0;
				min = 0;
				max = 100;
				step = 0;
				format = "%.0f";
			}
			item AUX_WEATHER_DEWPOINT {
				name = AUX_WEATHER_DEWPOINT_ITEM_NAME;
				label = "Dewpoint [째C]";
				value = 0;
				min = -50;
				max = 100;
				step = 0;
				format = "%.2f";
			}
		}
		number AUX_TEMPERATURE_SENSORS {
			name = AUX_TEMPERATURE_SENSORS_PROPERTY_NAME;
			group = WEATHER_GROUP;
			label = "Temperature sensors";
			perm = INDIGO_RO_PERM;
			// handle_change = false;
			// synchronized_change = false;
			// on_change { }
			// on_attach { }
			// on_detach { }
			item AUX_TEMPERATURE_SENSORS_SENSOR_1 {
				name = AUX_TEMPERATURE_SENSORS_SENSOR_1_ITEM_NAME;
				label = "Temperature (DHT22) [째C]";
				value = 0;
				min = -50;
				max = 100;
				step = 0;
				format = "%.2f";
			}
			item AUX_TEMPERATURE_SENSORS_SENSOR_2 {
				name = AUX_TEMPERATURE_SENSORS_SENSOR_2_ITEM_NAME;
				label = "Temperature (Temp probe) [째C]";
				value = 0;
				min = -50;
				max = 100;
				step = 0;
				format = "%.2f";
			}
		}
		light AUX_DEW_WARNING {
			name = AUX_DEW_WARNING_PROPERTY_NAME;
			group = WEATHER_GROUP;
			label = "Dew warning";
			// handle_change = false;
			// synchronized_change = false;
			// on_change { }
			// on_attach { }
			// on_detach { }
			item AUX_DEW_WARNING_SENSOR_1 {
				name = AUX_DEW_WARNING_SENSOR_1_ITEM_NAME;
				label = "Dew warning (DHT22)";
				value = INDIGO_IDLE_STATE;
			}
		}
		number AUX_INFO {
			name = AUX_INFO_PROPERTY_NAME;
			group = AUX_GROUP;
			label = "Sensors";
			perm = INDIGO_RO_PERM;
			// handle_change = false;
			// synchronized_change = false;
			// on_change { }
			// on_attach { }
			// on_detach { }
			item AUX_INFO_VOLTAGE {
				name = AUX_INFO_VOLTAGE_ITEM_NAME;
				label = "Voltage [V]";
				value = 0;
				min = 0;
				max = 15;
				step = 0;
				format = "%.2f";
			}
			item AUX_INFO_CURRENT {
				name = AUX_INFO_CURRENT_ITEM_NAME;
				label = "Current [A]";
				value = 0;
				min = 0;
				max = 20;
				step = 0;
				format = "%.2f";
			}
		}
		switch X_AUX_CALIBRATE {
			name = "X_AUX_CALIBRATE";
			group = AUX_ADVANCED_GROUP;
			label = "Calibrate sensors";
			// handle_change = false;
			// synchronized_change = false;
			on_change {
				if (X_AUX_CALIBRATE_ITEM->sw.value) {
					wbplusv3_command(device, "66300744");
					indigo_sleep(1);
					X_AUX_CALIBRATE_ITEM->sw.value = false;
					indigo_send_message(device, "Seensors recallibrated");
				}
			}
			// on_attach { }
			// on_detach { }
			item X_AUX_CALIBRATE {
				name = "CALIBRATE";
				label = "Calibrate";
				value = false;
			}
		}
	}
}
