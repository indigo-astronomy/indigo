// Copyright (c) 2016-2025 CloudMakers, s. r. o.
// All rights reserved.
//
// You can use this software under the terms of 'INDIGO Astronomy
// open-source license' (see LICENSE.md).
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHORS 'AS IS' AND ANY EXPRESS
// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Shoestring DSUSB shutter release driver definition

// version history
// 2.0 by Peter Polakovic <peter.polakovic@cloudmakers.eu>
// 3.0 refactoring by Peter Polakovic <peter.polakovic@cloudmakers.eu>

// TODO: Add libdsusb for windows

driver dsusb {
	label = "Shoestring DSUSB shutter release";
	author = "Peter Polakovic <peter.polakovic@cloudmakers.eu>";
	copyright = "Copyright (c) 2016-2025 CloudMakers, s. r. o.";
	version = 11;
	libusb {
		hotplug = true;
		vid = DSUSB_VID;
	}
	include {
		#include <libdsusb.h>
	}
	data {
		libdsusb_device_context *device_context;
	}
	code {
		static bool dsusb_match(libusb_device *dev, const char **name) {
			return libdsusb_shutter(dev, name);
		}

		static bool dsusb_open(indigo_device *device) {
			return libdsusb_open(PRIVATE_DATA->usbdev, &PRIVATE_DATA->device_context);
		}

		static void dsusb_close(indigo_device *device) {
			libdsusb_close(PRIVATE_DATA->device_context);
		}

		static void dsusb_debug(const char *message) {
			INDIGO_DRIVER_DEBUG(DRIVER_NAME, "libdsusb: %s\n", message);
		}
	}
	on_init {
		libdsusb_debug = &dsusb_debug;
	}
	aux {
		name = "%s";
		interface = INDIGO_INTERFACE_AUX_SHUTTER;
		on_timer {
			if (CCD_EXPOSURE_PROPERTY->state == INDIGO_BUSY_STATE) {
				CCD_EXPOSURE_ITEM->number.value--;
				if (CCD_EXPOSURE_ITEM->number.value <= 0) {
					CCD_EXPOSURE_ITEM->number.value = 0;
					CCD_EXPOSURE_PROPERTY->state = INDIGO_OK_STATE;
					libdsusb_stop(PRIVATE_DATA->device_context);
				}
				indigo_update_property(device, CCD_EXPOSURE_PROPERTY, NULL);
				if (CCD_EXPOSURE_ITEM->number.value > 0) {
					indigo_execute_priority_handler_in(device, 100, CCD_EXPOSURE_ITEM->number.value < 1 ? CCD_EXPOSURE_ITEM->number.value : 1, aux_timer_callback);
				}
			}
		}
		on_connect {
			CCD_EXPOSURE_ITEM->number.value = CCD_EXPOSURE_ITEM->number.target = 0;
			CCD_EXPOSURE_PROPERTY->state = INDIGO_OK_STATE;
		}
		on_disconnect {
			libdsusb_stop(PRIVATE_DATA->device_context);
		}
		switch CCD_ABORT_EXPOSURE {
			name = CCD_ABORT_EXPOSURE_PROPERTY_NAME;
			group = AUX_MAIN_GROUP;
			label = "Abort exposure";
			rule = INDIGO_ANY_OF_MANY_RULE;
			on_change {
				if (CCD_ABORT_EXPOSURE_ITEM->sw.value && CCD_EXPOSURE_PROPERTY->state == INDIGO_BUSY_STATE) {
					indigo_cancel_pending_handler(device, aux_timer_callback);
					libdsusb_stop(PRIVATE_DATA->device_context);
					CCD_EXPOSURE_PROPERTY->state = INDIGO_ALERT_STATE;
					indigo_update_property(device, CCD_EXPOSURE_PROPERTY, NULL);
				}
				CCD_ABORT_EXPOSURE_ITEM->sw.value = false;
				CCD_ABORT_EXPOSURE_PROPERTY->state = INDIGO_OK_STATE;
			}
			item CCD_ABORT_EXPOSURE {
				name = CCD_ABORT_EXPOSURE_ITEM_NAME;
				label = "Abort exposure";
				value = false;
			}
		}
		number CCD_EXPOSURE {
			name = CCD_EXPOSURE_PROPERTY_NAME;
			group = AUX_MAIN_GROUP;
			label = "Start exposure";
			on_change {
				CCD_EXPOSURE_PROPERTY->state = INDIGO_BUSY_STATE;
				if (X_CONFIG_FOCUS_ITEM->sw.value) {
					libdsusb_focus(PRIVATE_DATA->device_context);
					indigo_usleep(1000000);
				}
				libdsusb_start(PRIVATE_DATA->device_context);
				CCD_EXPOSURE_PROPERTY->state = INDIGO_BUSY_STATE;
				indigo_execute_priority_handler_in(device, 100, CCD_EXPOSURE_ITEM->number.value < 1 ? CCD_EXPOSURE_ITEM->number.value : 1, aux_timer_callback);
			}
			item CCD_EXPOSURE {
				name = CCD_EXPOSURE_ITEM_NAME;
				label = "Start exposure";
				max = 1000;
				step = 1;
				format = "%g";
			}
		}
		switch X_CONFIG {
			name = "X_CONFIG";
			group = AUX_MAIN_GROUP;
			label = "Configure";
			rule = INDIGO_ANY_OF_MANY_RULE;
			persistent = true;
			item X_CONFIG_FOCUS {
				name = "FOCUS";
				label = "Focus before capture";
				value = false;
			}
		}
	}
}
